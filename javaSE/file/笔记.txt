
			第6单元:访问权限控制
			
1.	静态导入：import static util.Print.*;
  	功能：导入指定类中所有的静态方法
  	
2.	包结构是为了防止类名冲突

3.	package必须是文件只第一句非注释代码

4.	控制对成员的访问权限有两个原因。
		第一是为了使用户不要碰触那些他们不该碰触的部分 ,
	这些部分对于类内部的操作是必要的,但是它并不属于客户端程序员所需接口的一部分。因此,
	将方法和域指定成private,对客户端程序员而言是一种服务。因为这样他们可以很清楚地看到
	什么对他们重要,什么是他们可以忽略的。这样简化了他们对类的理解。
		第二个原因,也是最重要的原因,是为了让类库设计者可以更改类的内部工作方式,而不必担心这样
	会对客户端程序员产生重大的影响。例如,最初可能会以某种方式创建一个类,然后发现如果更改程
	序结构,可以大大提高运行速度。如果接口和实现可以被明确地隔离和加以,保护,那么就可以实现
	这一目的,而不必强制客户端程序员重新编写代码。访问权限控制可以确保不会有任何客户端程序员
	依赖于某个类的底层实现的任何部分。当具备了改变底层实施细节的能力时,不仅可以随意地改善设计
	,还可能会随意地犯错误,同时也就有了犯错的可能性。无论如何细心地计划并设计,都有可能犯错。当
	了解到你所犯错,误是相对安全的时候,就可以更加放心地进行实验,也就可以更快地学会,更快地完成项目。
	
	
			第七章：复用类
			
1.	域(成员变量)初始化方式：
		1.定义的时候初始化，保证在构造器之前
		2.构造器中初始化
		3.调用的时候初始化，惰性初始化
		
2.	继承：
		1.基类(父类)中所有的方法必须是public的，所有数据成员指定为private
		2.可以将继承是为对类的复用
		3.super关键字
		4.当创建一个导出类(子类)的对象时，该对象会包含一个基类的子对象，基类的
		     子对象被包含在导出类对象内部
		5.构建导出类的过程是从基类向外扩散的，所以积累在导出类构造器可以访问它之前
		     就已经完成了初始化
		6.基类对象初始化在导出类成员属性初始化之前,在导出类静态属性初始化之后
		7.初始化顺序：导出类静态对象--》父类构造器--》导出类成员--》导出类构造器
		
	
	

	